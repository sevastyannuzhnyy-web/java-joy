  inventoryById: Record<string, InventoryRecord>
  loading: boolean
  reload: () => Promise<void>
}

const InventoryContext = createContext<InventoryContextValue | undefined>(undefined)

async function fetchInventory(): Promise<Record<string, InventoryRecord>> {
  const { data, error } = await supabase
    .from('menu_items')
    .select('id, price, is_available')

  if (error) throw error

  const mapped: Record<string, InventoryRecord> = {}

  ;(data || []).forEach((row) => {
    if (!row?.id) return
    const priceValue = Number(row.price)
    mapped[row.id] = {
      price: Number.isFinite(priceValue) ? priceValue : undefined,
      is_available: row.is_available ?? true,
    }
  })

  return mapped
}

export const InventoryProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [inventoryById, setInventoryById] = useState<Record<string, InventoryRecord>>({})
  const [loading, setLoading] = useState(true)

  const reload = useCallback(async () => {
    try {
      setLoading(true)
      const mapped = await fetchInventory()
      setInventoryById(mapped)
    } catch (error) {
      console.error('Failed to load menu inventory', error)
    } finally {
      setLoading(false)
    }
  }, [])

  useEffect(() => {
    reload()
  }, [reload])

  useEffect(() => {
    const channel = supabase
      .channel('menu-items-inventory')
      .on('postgres_changes', { event: '*', schema: 'public', table: 'menu_items' }, async (payload) => {
        setInventoryById((prev) => {
          const next = { ...prev }
          if (payload.eventType === 'DELETE') {
            const record = payload.old as { id?: string }
            if (record?.id) {
              delete next[record.id]
            }
          } else {
            const record = payload.new as { id?: string; price?: number | string | null; is_available?: boolean }
            if (record?.id) {
              const priceValue = Number(record.price)
              next[record.id] = {
                price: Number.isFinite(priceValue) ? priceValue : next[record.id]?.price,
                is_available: record.is_available ?? true,
              }
            }
          }
          return next
        })
      })
      .subscribe()

    return () => {
      supabase.removeChannel(channel)
    }
  }, [])

  const value = useMemo(
    () => ({
      inventoryById,
      loading,
      reload,
    }),
    [inventoryById, loading, reload]
  )

  return (
    <InventoryContext.Provider value={value}>
      {children}
    </InventoryContext.Provider>
  )
}

export function useInventory() {
  const context = useContext(InventoryContext)
  if (!context) {
    throw new Error('useInventory must be used within an InventoryProvider')
  }
  return context
}
